public struct Response: Identifiable, Codable, Equatable, Sendable {
	public struct Config: Codable, Equatable, Sendable {
		public enum Conversation: String, Codable, Equatable, Sendable {
			/// The contents of the response will be added to the default conversation.
			case auto
			/// An out-of-band response which will not add items to default conversation.
			case none
		}

		/// The modalities for the response.
		public let modalities: [Session.Modality]
		/// Instructions for the model.
		public let instructions: String
		/// The voice the model uses to respond.
		public let voice: Session.Voice
		/// The format of output audio.
		public let outputAudioFormat: Session.AudioFormat
		/// Tools (functions) available to the model.
		public let tools: [Session.Tool]
		/// How the model chooses tools.
		public let toolChoice: Session.ToolChoice
		/// Sampling temperature.
		public let temperature: Double
		/// Maximum number of output tokens.
		public let maxResponseOutputTokens: Int?
		/// Controls which conversation the response is added to.
		public let conversation: Conversation?
		/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
		public let metadata: [String: String]?
		/// Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation.
		public let input: [Item]?

		public init(modalities: [Session.Modality] = [.text, .audio], instructions: String, voice: Session.Voice = .alloy, outputAudioFormat: Session.AudioFormat = .pcm16, tools: [Session.Tool] = [], toolChoice: Session.ToolChoice = .auto, temperature: Double = 1, maxResponseOutputTokens: Int? = nil, conversation: Conversation? = .auto, metadata: [String: String]? = nil, input: [Item]? = nil) {
			self.input = input
			self.voice = voice
			self.tools = tools
			self.metadata = metadata
			self.toolChoice = toolChoice
			self.modalities = modalities
			self.temperature = temperature
			self.instructions = instructions
			self.conversation = conversation
			self.outputAudioFormat = outputAudioFormat
			self.maxResponseOutputTokens = maxResponseOutputTokens
		}
	}

	public enum Status: String, Codable, Equatable, Sendable {
		case failed
		case completed
		case cancelled
		case incomplete
		case inProgress = "in_progress"
	}

	public struct Usage: Codable, Equatable, Sendable {
		public let totalTokens: Int
		public let inputTokens: Int
		public let outputTokens: Int
		public let inputTokenDetails: InputTokenDetails
		public let outputTokenDetails: OutputTokenDetails

		public struct InputTokenDetails: Codable, Equatable, Sendable {
			public let textTokens: Int
			public let audioTokens: Int
			public let cachedTokens: Int
			public let cachedTokensDetails: CachedTokensDetails

			public struct CachedTokensDetails: Codable, Equatable, Sendable {
				public let textTokens: Int
				public let audioTokens: Int
			}
		}

		public struct OutputTokenDetails: Codable, Equatable, Sendable {
			public let textTokens: Int
			public let audioTokens: Int
		}
	}

	/// The unique ID of the response.
	public let id: String
	/// The status of the response.
	public let status: Status
	/// The list of output items generated by the response.
	public let output: [Item]
	/// Usage statistics for the response.
	public let usage: Usage?
	/// Developer-provided string key-value pairs associated with this response.
	public let metadata: [String: String]?
}
